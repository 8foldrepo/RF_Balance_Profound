Index: manager.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import sys\r\nfrom datetime import date\r\nimport re\r\nimport pyvisa\r\nfrom PyQt5.QtWidgets import QApplication\r\nfrom PyQt5.QtCore import QMutex, QObject, QThread, QWaitCondition, pyqtSignal, pyqtSlot\r\nfrom typing import Optional\r\nfrom collections import OrderedDict\r\nimport distutils.util\r\n\r\nfrom Utilities.load_config import ROOT_LOGGER_NAME, LOGGER_FORMAT\r\nimport logging\r\n\r\nlog_formatter = logging.Formatter(LOGGER_FORMAT)\r\n\r\nimport time as t\r\nimport numpy as np\r\nfrom scipy import integrate\r\n\r\nfrom Utilities.useful_methods import log_msg, get_element_distances\r\nfrom Utilities.formulas import calculate_power_from_balance_reading\r\nfrom definitions import ROOT_DIR\r\nimport os\r\n\r\nbalance_logger = logging.getLogger('wtf_log')\r\nfile_handler = logging.FileHandler(os.path.join(ROOT_DIR, \"./logs/wtf.log\"), mode='w')\r\nfile_handler.setFormatter(log_formatter)\r\nbalance_logger.addHandler(file_handler)\r\nbalance_logger.setLevel(logging.INFO)\r\nroot_logger = logging.getLogger(ROOT_LOGGER_NAME)\r\n\r\npump_status = \"\"\r\ntank_status = \"\"\r\n\r\n\r\nclass Manager(QThread):\r\n    \"\"\"\r\n    this class acts as the chief executive for the application. It is in charge of recieving commands from the UI,\r\n    dictating actions to other classes, and emitting feedback back to the UI\r\n\r\n    Signals:\r\n        logger_signal: convey info to the user via a feedback widget\r\n        finished_signal: emitted when the thread is ready to be deleted.\r\n\r\n        description_signal = pyqtSignal(str): Convey script metadata to UI\r\n        created_on_signal = pyqtSignal(str): Convey script metadata to UI\r\n        num_tasks_signal = pyqtSignal(str): Convey script metadata to UI\r\n\r\n    Slots:\r\n        execute_command: execute a command given to the application\r\n\r\n    Methods:\r\n\r\n    \"\"\"\r\n\r\n    # Dialog signals\r\n    pretest_dialog_signal = pyqtSignal(str)  # str is date (man -> mainwindow)\r\n    user_prompt_signal = pyqtSignal(str)  # str is message for user to read\r\n    user_prompt_pump_not_running_signal = pyqtSignal(str)  # str is pump status\r\n    user_prompt_signal_water_too_low_signal = pyqtSignal(str)  # str is water level\r\n    write_cal_data_to_ua_signal = pyqtSignal(list)  # list is 2d array of calibration data\r\n    retracting_ua_warning_signal = pyqtSignal()\r\n\r\n    # Script metadata\r\n    description_signal = pyqtSignal(str)\r\n    created_on_signal = pyqtSignal(str)\r\n    created_by_signal = pyqtSignal(str)\r\n    num_tasks_signal = pyqtSignal(int)\r\n    script_name_signal = pyqtSignal(str)\r\n    step_number_signal = pyqtSignal(int)\r\n    expand_step_signal = pyqtSignal(int)\r\n    element_number_signal = pyqtSignal(str)\r\n    script_info_signal = pyqtSignal(list)\r\n\r\n    plot_signal = pyqtSignal(object, object)\r\n\r\n    logger_signal = pyqtSignal(str)\r\n    finished_signal = pyqtSignal()\r\n\r\n    # Tab signal\r\n    profile_plot_signal = pyqtSignal(list, list, str)\r\n    plot_signal = pyqtSignal(list, list, float)  # float is refresh rate\r\n    rfb_tab_signal = pyqtSignal(dict)\r\n    # contains\r\n\r\n    Motors = None\r\n\r\n    def __init__(self, parent: Optional[QObject], config: dict):\r\n        super().__init__(parent=parent, objectName=u\"manager_thread\")\r\n        self.get_position_cooldown_s = .2  # decreasing this improves the refresh rate of the position, at the cost of responsiveness\r\n        self.last_get_position_time = 0\r\n        self.app = QApplication.instance()\r\n        self.scan_data = dict()\r\n        self.config = config\r\n        self.element_x_coordinates = get_element_distances(\r\n            element_1_index=self.config['WTF_PositionParameters']['X-Element1'],\r\n            element_pitch=self.config['WTF_PositionParameters']['X-Element pitch (mm)'])\r\n\r\n        #put a none at position zero because there is no element zero\r\n        self.element_r_coordinates = [None]\r\n        #fill in default theta home coordinates\r\n        for i in range(10):\r\n            self.element_r_coordinates.append(self.config['WTF_PositionParameters']['ThetaHomeCoord'])\r\n\r\n        # Used to prevent other threads from accessing the motor class\r\n        self.motor_control_lock = QMutex()\r\n\r\n        self.test_data = dict()\r\n        self.test_data[\"operarator_name\"] = None\r\n        self.test_data[\"ua_serial_number\"] = None\r\n        self.test_data[\"test_comment\"] = None\r\n\r\n        self.freq_highlimit_hz = None\r\n        self.freq_lowlimit_hz = None\r\n        self.parent = parent\r\n        self.stay_alive = True\r\n\r\n        # Stores latest command to be executed in the event loop\r\n        self.cmd = ''\r\n\r\n        # Event loop control vars\r\n        self.mutex = QMutex()\r\n        self.condition = QWaitCondition()\r\n\r\n        # Test Metadata\r\n        self.test_comment = \"\"\r\n        self.ua_serial_number = \"\"\r\n        self.operator_name = \"\"\r\n\r\n        # Script file\r\n        self.script = None\r\n\r\n        # Script data\r\n        self.taskArgs = None\r\n        self.taskExecOrder = None\r\n        self.taskNames = None\r\n\r\n        # Script control vars\r\n        self.scripting = False\r\n        self.continue_var = True\r\n        self.retry_var = False  # keep track of whether user wants to try script iteration, default false\r\n\r\n        # Keeps track of script step in progress\r\n        self.step_complete = True\r\n        self.step_index = -1\r\n\r\n        self.devices = list()\r\n        self.add_devices()\r\n\r\n    def test_code(self):\r\n        # # todo: test code, remove later\r\n        # self.scripting = True\r\n        #\r\n        #\r\n        variable_list = dict()\r\n        # variable_list[\"Task type\"] = \"Find element \\\"n\\\"\"\r\n        # variable_list[\"Element\"] = \"Element 1\"\r\n        # variable_list[\"X Incr. (mm)\"] = \"0.250000\"\r\n        # variable_list[\"X #Pts.\"] = \"21\"\r\n        # variable_list[\"Theta Incr. (deg)\"] = \"-0.400000\"\r\n        # variable_list[\"Theta #Pts.\"] = \"41\"\r\n        # variable_list[\"Scope channel\"] = \"Channel 1\"\r\n        # variable_list[\"Acquisition type\"] = \"N Averaged Waveform\"\r\n        # variable_list[\"Averages\"] = \"16\"\r\n        # variable_list[\"Data storage\"] = \"Do not store\"\r\n        # variable_list[\"Storage location\"] = \"UA results directory\"\r\n        # variable_list[\"Data directory\"] = \"\"\r\n        # variable_list[\"Max. position error (+/- mm)\"] = \"0.200000\"\r\n        # variable_list[\"ElementPositionTest\"] = \"FALSE\"\r\n        # variable_list[\"Max angle variation (deg)\"] = \"2.000000\"\r\n        # variable_list[\"BeamAngleTest\"] = \"FALSE\"\r\n        # variable_list[\"Frequency settings\"] = \"Avg. Low frequency\"\r\n        # variable_list[\"Auto set timebase\"] = \"TRUE\"\r\n        # variable_list[\"#Cycles.Capture\"] = \"10\"\r\n        # variable_list[\"#Cycles.Delay\"] = \"0\"\r\n        # variable_list[\"Frequency (MHz)\"] = \"4.400000\"\r\n        # variable_list[\"Amplitude (mV)\"] = \"50.000000\"\r\n        # variable_list[\"Burst count\"] = \"50\"\r\n        # return variable_list\r\n\r\n        # self.find_element(variable_list)\r\n\r\n        variable_list[\"Element\"] = \"Current\"\r\n        variable_list[\"Frequency range\"] = \"Low frequency\"\r\n        variable_list[\"RFB.#on/off cycles\"] = \"3\"\r\n        variable_list[\"RFB.On time (s)\"] = \"10.000000\"\r\n        variable_list[\"RFB.Off time (s)\"] = \"10.000000\"\r\n        variable_list[\"RFB.Threshold\"] = \"0.050000\"\r\n        variable_list[\"RFB.Offset\"] = \"0.500000\"\r\n        variable_list[\"Set frequency options\"] = \"Common peak frequency\"\r\n        variable_list[\"Frequency (MHz)\"] = \"4.200000\"\r\n        variable_list[\"Amplitude (mVpp)\"] = \"100.000000\"\r\n        variable_list[\"Storage location\"] = \"UA results directory\"\r\n        variable_list[\"Data directory\"] = \"\"\r\n        variable_list[\"RFB target position\"] = \"Average UA RFB position\"\r\n        variable_list[\"RFB target angle\"] = \"-90.000000\"\r\n        variable_list[\"EfficiencyTest\"] = \"TRUE\"\r\n        variable_list[\"Pa max (target, W)\"] = \"4.000000\"\r\n        variable_list[\"Pf max (limit, W)\"] = \"12.000000\"\r\n        variable_list[\"Reflection limit (%)\"] = \"70.000000\"\r\n\r\n        self.measure_element_efficiency_rfb(variable_list=variable_list)\r\n\r\n    def add_devices(self):\r\n        # -> check if we are simulating hardware\r\n        self.SIMULATE_HARDWARE = self.config['Debugging']['simulate_hw']\r\n        self.SIMULATE_MOTORS = self.config['Debugging']['simulate_motors']\r\n        self.SIMULATE_OSCILLOSCOPE = self.config['Debugging']['simulate_oscilloscope']\r\n\r\n        from Hardware.Abstract.abstract_sensor import AbstractSensor\r\n        self.thermocouple = AbstractSensor(config=self.config)\r\n\r\n        if self.SIMULATE_MOTORS:\r\n            from Hardware.Abstract.abstract_motor_controller import AbstractMotorController\r\n            self.Motors = AbstractMotorController(config=self.config)\r\n        else:\r\n            from Hardware.VIX_Motor_Controller import VIX_Motor_Controller\r\n            self.Motors = VIX_Motor_Controller(config=self.config, lock=self.motor_control_lock)\r\n\r\n        self.rm = None\r\n\r\n        if self.SIMULATE_OSCILLOSCOPE:\r\n            from Hardware.Abstract.abstract_oscilloscope import AbstractOscilloscope\r\n            self.Oscilloscope = AbstractOscilloscope()\r\n        else:\r\n            from Hardware.keysight_oscilloscope import KeysightOscilloscope\r\n            self.rm = pyvisa.ResourceManager()\r\n            self.Oscilloscope = KeysightOscilloscope(config=self.config, resource_manager=self.rm)\r\n\r\n        if self.SIMULATE_HARDWARE:\r\n            from Hardware.Abstract.abstract_awg import AbstractAWG\r\n            from Hardware.Abstract.abstract_balance import AbstractBalance\r\n            from Hardware.Abstract.abstract_motor_controller import AbstractMotorController\r\n            from Hardware.Abstract.abstract_power_meter import PowerMeter\r\n            from Hardware.Abstract.abstract_io_board import IO_Board\r\n            from Hardware.Abstract.abstract_interface_box import UAInterfaceBox\r\n\r\n            self.AWG = AbstractAWG(config=self.config)\r\n            self.Balance = AbstractBalance(config=self.config)\r\n            self.Forward_Power_Meter = PowerMeter(config=self.config, device_key='Forward_Power_Meter')\r\n            self.Reflected_Power_Meter = PowerMeter(config=self.config, device_key='Reflected_Power_Meter')\r\n            self.IO_Board = IO_Board(config=self.config)\r\n            self.UAInterface = UAInterfaceBox(config=self.config)\r\n        else:\r\n            from Hardware.mini_circuits_power_meter import PowerMeter\r\n            from Hardware.MT_balance import MT_balance\r\n            from Hardware.ua_interface_box import UAInterfaceBox\r\n            from Hardware.ni_daq_board import NI_DAQ\r\n            from Hardware.mini_circuits_power_meter import PowerMeter\r\n\r\n            if self.rm is None:\r\n                self.rm = pyvisa.ResourceManager()\r\n            from Hardware.keysight_awg import KeysightAWG\r\n            self.AWG = KeysightAWG(config=self.config, resource_manager=self.rm)\r\n            self.Balance = MT_balance(config=self.config)\r\n            self.UAInterface = UAInterfaceBox(config=self.config)\r\n            self.IO_Board = NI_DAQ(config=self.config)\r\n            self.Forward_Power_Meter = PowerMeter(config=self.config, device_key='Forward_Power_Meter')\r\n            self.Reflected_Power_Meter = PowerMeter(config=self.config, device_key='Reflected_Power_Meter')\r\n\r\n        self.devices.append(self.Forward_Power_Meter)\r\n        self.devices.append(self.Reflected_Power_Meter)\r\n        self.devices.append(self.IO_Board)\r\n        self.devices.append(self.UAInterface)\r\n        self.devices.append(self.Motors)\r\n        self.devices.append(self.thermocouple)\r\n        self.devices.append(self.Oscilloscope)\r\n        self.devices.append(self.Balance)\r\n        self.devices.append(self.AWG)\r\n\r\n    def connect_hardware(self):\r\n        for device in self.devices:\r\n            device.connect_hardware()\r\n        t.sleep(2)\r\n        # For testing purposes\r\n        # self.findRMS(search_mode=\"coarse\", frequency_mode=\"LF\")\r\n\r\n    def disconnect_hardware(self):\r\n        for device in self.devices:\r\n            device.disconnect_hardware()\r\n\r\n    def run(self) -> None:\r\n        \"\"\"\r\n        Overloaded function from QThread, this is the main scope control thread\r\n        function.\r\n        \"\"\"\r\n        self.mutex.lock()\r\n        self.starttime = t.time()\r\n\r\n        self.stay_alive = True\r\n\r\n        while self.stay_alive is True:\r\n            wait_bool = self.condition.wait(self.mutex, 50)\r\n\r\n            if self.stay_alive is False:\r\n                break\r\n\r\n            self.cmd = self.cmd.upper()\r\n            cmd_ray = self.cmd.split(' ')\r\n            if cmd_ray[0] == 'LOAD':\r\n                log_msg(self, root_logger, level='info', message=\"Loading script\")\r\n                try:\r\n                    cmd_ray.pop(0)\r\n                    path = ' '.join(cmd_ray)\r\n                    self.load_script(path)\r\n                except Exception as e:\r\n                    log_msg(self, root_logger, \"info\", f\"Error in load script: {e}\")\r\n            elif cmd_ray[0] == 'RUN':\r\n                log_msg(self, root_logger, level='info', message=\"Running script\")\r\n                self.abort()\r\n                self.scripting = True\r\n            elif cmd_ray[0] == 'CLOSE':\r\n                self.wrap_up()\r\n            elif cmd_ray[0] == 'CONNECT':\r\n                self.connect_hardware()\r\n            elif cmd_ray[0] == 'MOTOR':\r\n                self.Motors.exec_command(self.cmd)\r\n            # Todo: For testing purposes, remove later\r\n            elif cmd_ray[0] == 'TEST':\r\n                self.test_code()\r\n            # What to do when there is no command\r\n            else:\r\n                if self.scripting:\r\n                    if self.taskNames is None:\r\n                        self.abort()\r\n                    else:\r\n                        self.advance_script()\r\n                else:\r\n                    if self.Oscilloscope.connected:\r\n                        self.capture_and_plot()\r\n                    else:\r\n                        pass\r\n                    self.update_motor_position()\r\n                    if self.thermocouple.connected:\r\n                        self.thermocouple.get_reading()\r\n\r\n            self.cmd = \"\"\r\n        self.wrap_up()\r\n        self.mutex.unlock()\r\n\r\n        return super().run()\r\n\r\n    def update_motor_position(self):\r\n        if self.Motors.connected and self.parent.tabWidget.tabText(self.parent.tabWidget.currentIndex()) == 'Position':\r\n            if t.time() - self.last_get_position_time > self.get_position_cooldown_s:\r\n                lock_aquired = self.motor_control_lock.tryLock()\r\n\r\n                if lock_aquired:\r\n                    self.Motors.get_position(mutex_locked=True)\r\n                    self.last_get_position_time = t.time()\r\n                    self.motor_control_lock.unlock()\r\n\r\n    def capture_and_plot(self):\r\n        # Do these things if a script is not being run\r\n\r\n        # Only capture if the scan tab is selected\r\n        if not self.parent.scan_tab_widget.plot_ready:\r\n            return\r\n        if not self.parent.tabWidget.tabText(self.parent.tabWidget.currentIndex()) == 'Scan':\r\n            return\r\n\r\n        tabs = self.parent.scan_tab_widget.scan_tabs\r\n\r\n        if not tabs.tabText(tabs.currentIndex()) == \"1D Scan\":\r\n            return\r\n\r\n        try:\r\n            time, voltage = self.Oscilloscope.capture(channel=1)\r\n            time_elapsed = t.time() - self.starttime\r\n            if time_elapsed != 0:\r\n                self.refresh_rate = (round(1 / (time_elapsed), 1))\r\n\r\n            self.plot_signal.emit(time, voltage, self.refresh_rate)\r\n        except pyvisa.errors.InvalidSession:\r\n            self.log(\"Could not plot, oscilloscope resource closed\")\r\n\r\n        self.starttime = t.time()\r\n\r\n    def load_script(self, path):\r\n        self.scripting = True\r\n        self.script = open(path, \"r\")\r\n\r\n        # Send name of script to UI\r\n        split_path = path.split('/')\r\n        name = split_path[len(split_path) - 1]\r\n        self.script_name_signal.emit(name)\r\n\r\n        tasks = []  # the upper layer of our variable list\r\n        loops = []\r\n        self.taskExecOrder = []\r\n        elementNamesForLoop = []\r\n        taskNoForLoop = []\r\n        currentLine = -1\r\n        addingElementsToLoop = False\r\n        buildingLoop = False\r\n        taskVars = OrderedDict()  # the list of variables for the individual task\r\n        taskNo = -2  # keeps track of the task number for indexing\r\n        f = open(path, \"r\")\r\n        for line in self.script:\r\n            ray = line.split(' = ')\r\n\r\n            if ray[0].upper() == '# OF TASKS':\r\n                self.num_tasks_signal.emit(int(ray[1].replace('\"', \"\")))\r\n            elif ray[0].upper() == 'CREATEDON':\r\n                self.created_on_signal.emit(ray[1].replace('\"', \"\"))\r\n            if ray[0].upper() == 'CREATEDBY':\r\n                self.created_by_signal.emit(ray[1].replace('\"', \"\"))\r\n            elif ray[0].upper() == 'DESCRIPTION':\r\n                self.description_signal.emit(ray[1].replace('\"', \"\"))\r\n\r\n            currentLine = currentLine + 1\r\n            if line == '\\n':\r\n                if taskVars:  # ensures task variable list isn't empty; prevents adding empty sub lists to main list\r\n                    tasks.append(OrderedDict(taskVars))\r\n                    taskVars.clear()  # empties out variable list for task since we're ready to move to the next set\r\n                if addingElementsToLoop:  # detects if we're done with the element name block for the loop in script\r\n                    addingElementsToLoop = False  # we're done with the block so set the flag to false\r\n                continue  # move forward one line\r\n            elif '[' in line:  # if the line we're on is a task line\r\n                taskNo = taskNo + 1  # increments the task number counter since we've moved to the next task\r\n                if \"Task\" in line and not buildingLoop:\r\n                    self.taskExecOrder.append(taskNo)  # adding task number to the execution list\r\n            else:  # above ensures we're not parsing a task header nor blank line\r\n                x0 = ray[0].strip()  # remove trailing/leading spaces\r\n                x1 = ray[1].strip().replace('\"', \"\")  # does above but also removes quotation marks\r\n                taskVars[x0] = x1  # add the temporary variable pair to the task's variable list\r\n\r\n                if \"# of Tasks\" in x0:\r\n                    numberOfTasks = x1\r\n\r\n                if \"Loop over elements\" in x1:  # detects if we've encountered a loop builder task\r\n                    buildingLoop = True  # set a flag that we're building a loop for the script\r\n                    addingElementsToLoop = True  # set a flag that we're adding element names from script for loop\r\n\r\n                if addingElementsToLoop and \"Element\" in x0:  # if we're on a line that adds an element name for the loop\r\n                    elementNamePre = x0.split(' ')  # split the left side of the variable assigner by space\r\n                    elementName = elementNamePre[\r\n                        1]  # retrieve the second word of the left side, that's the element name\r\n                    elementNamesForLoop.append(int(elementName))\r\n\r\n                if \"End loop\" in x1:  # script will have \"End loop\" in right side of task type to end loop block\r\n                    buildingLoop = False  # set the building loop flag to false since the loop block is done\r\n                    loops.append(list([list(elementNamesForLoop), list(taskNoForLoop)]))\r\n                    elementNamesForLoop.clear()\r\n                    taskNoForLoop.clear()\r\n                    self.taskExecOrder.pop()\r\n\r\n                    for i in range(len(loops[len(loops) - 1][0])):\r\n                        for j in range(len(loops[len(loops) - 1][1])):\r\n                            self.taskExecOrder.append([loops[len(loops) - 1][1][j], i + 1])\r\n\r\n                if buildingLoop and not addingElementsToLoop:  # if we're building a loop & are not in the name adding phase\r\n                    if taskNo not in taskNoForLoop:  # ensure the task no. isn't already in the task list for the loop\r\n                        taskNoForLoop.append(\r\n                            taskNo)  # add the current task no. to the list of tasks we need to run in loop\r\n\r\n        if taskVars:  # ensures task variable list isn't empty; prevents adding empty sub lists to main list\r\n            tasks.append(OrderedDict(taskVars))\r\n            taskVars.clear()  # empties out variable list for task since we're ready to move to the next set\r\n\r\n        for i in range(len(self.taskExecOrder)):\r\n            if not isinstance(self.taskExecOrder[i], list):\r\n                taskNoRemember = self.taskExecOrder[i]\r\n                toReplace = [taskNoRemember, None]\r\n                self.taskExecOrder[i] = toReplace\r\n\r\n        self.taskNames = list()\r\n        for i in range(len(self.taskExecOrder)):\r\n            self.taskNames.append(tasks[self.taskExecOrder[i][0] + 1]['Task type'])\r\n\r\n        self.taskArgs = list()\r\n        for i in range(len(self.taskExecOrder)):\r\n            # tasks[self.taskExecOrder[i][0] + 1].pop(\"Task type\", None)\r\n            self.taskArgs.append(tasks[self.taskExecOrder[i][0] + 1])\r\n\r\n        self.script_info_signal.emit(tasks)\r\n        self.num_tasks_signal.emit(len(self.taskNames))\r\n        f.close()\r\n        self.scripting = False\r\n\r\n    # Updates script step and executes the next step if applicable, and implements abort, continue, and retry\r\n    def advance_script(self):\r\n        if self.scripting is False:\r\n            return\r\n\r\n        if self.retry_var is True:\r\n            self.step_index = self.step_index - 1\r\n            self.step_complete = True\r\n            self.retry_var = False  # sets the retry variable to false so the retry function can happen again\r\n\r\n        # advance to the next step if the previous has been completed\r\n        if self.scripting and self.step_complete:\r\n            self.step_index = self.step_index + 1\r\n\r\n        # if a script is being executed, and the step index is valid, and the previous step is complete,\r\n        # run the next script step\r\n\r\n        if self.taskArgs is not None and self.taskNames is not None and self.taskExecOrder is not None:\r\n            if self.scripting and 0 <= self.step_index < len(self.taskNames):\r\n\r\n                if self.step_complete:\r\n                    self.step_complete = False\r\n                    self.execute_script_step(self.step_index)\r\n        elif self.step_index >= len(self.taskNames):\r\n            self.abort()\r\n\r\n    '''Executes script step with given step index in taskNames/taskArgs'''\r\n\r\n    def execute_script_step(self, step_index):\r\n        if self.taskArgs is None or self.taskNames is None or self.taskExecOrder is None:\r\n            self.abort()\r\n            return\r\n\r\n        name = self.taskNames[step_index]  # sets name (str) to current iteration in taskNames list\r\n        args = self.taskArgs[step_index]  # sets args (list) to current iteration in taskArgs list\r\n\r\n        self.step_number_signal.emit(step_index - 1)\r\n        t.sleep(.1)\r\n\r\n        self.expand_step_signal.emit(self.taskExecOrder[step_index][0])\r\n\r\n        if not self.taskExecOrder[step_index][1] is None:  # if the element in the self.taskExecOrder isn't None\r\n            # below: set the element to be operated on to the one in self.taskExecOrder\r\n            args['Element'] = self.taskExecOrder[step_index][1]\r\n\r\n        if \"Measure element efficiency (RFB)\".upper() in name.upper():\r\n            self.measure_element_efficiency_rfb(args)\r\n        elif name.upper() == \"Pre-test initialisation\".upper():\r\n            self.pretest_initialization(args)\r\n        elif \"Find element n\".upper() in name.upper():\r\n            self.find_element(args)\r\n        elif name.upper() == \"Save results\".upper():\r\n            self.save_results(args, self.test_data)\r\n        elif name.upper() == \"Prompt user for action\".upper():\r\n            self.prompt_user_for_action(args)\r\n        elif \"Home system\".upper() in name.upper():\r\n            self.home_system(args)\r\n\r\n        self.step_number_signal.emit(step_index)\r\n\r\n        # below: this should allow for the retry function by setting the iteration variable backwards 1\r\n        # so when it gets incremented it returns to the previous position\r\n\r\n    '''Aborts script'''\r\n\r\n    @pyqtSlot()\r\n    def abort(self):\r\n        self.log('Aborting script')\r\n        # Reset script control variables\r\n        self.scripting = False\r\n        self.step_index = -1\r\n        self.step_complete = True\r\n        self.continue_var = True\r\n        self.step_number_signal.emit(-1)\r\n\r\n        # Todo: add option to save before exiting\r\n\r\n        self.erase_metadata()\r\n\r\n    def erase_metadata(self):\r\n        self.ua_serial_number = None\r\n        self.test_comment = None\r\n        self.operator_name = None\r\n\r\n    '''Sets continue variable to False and waits for it to be true, disabling scripting if abort_var is true'''\r\n\r\n    def wait_for_cont(self):\r\n        self.continue_var = False\r\n        while not self.continue_var:\r\n            if self.scripting == False:\r\n                # Always handle this exception\r\n                raise AbortException\r\n\r\n    '''Continues execution of script'''\r\n\r\n    @pyqtSlot()\r\n    def cont(self):\r\n        self.continue_var = True\r\n\r\n    '''Retries current step'''\r\n\r\n    @pyqtSlot()\r\n    def retry(self):\r\n        self.retry_var = True\r\n\r\n    def write_cal_data_to_ua_button(self):\r\n        # Todo: make this method write calibration data to UA\r\n        pass\r\n\r\n    '''Collects metadata from user and prompts user until water level is ok'''\r\n\r\n    def pretest_initialization(self, variable_list):\r\n        today = date.today()\r\n        formatted_date = today.strftime(\"%m/%d/%Y\")\r\n\r\n        # Show dialog until name and serial number are input\r\n        while self.operator_name == \"\" or self.ua_serial_number == \"\":\r\n            self.pretest_dialog_signal.emit(\r\n                formatted_date)  # sends signal from manager to MainWindow to open dialog box\r\n            try:\r\n                self.wait_for_cont()\r\n            except AbortException:\r\n                return self.abort()\r\n\r\n        # Show dialogs until pump is on and the water sensor reads level\r\n        while True:\r\n            break #todo: remove this line later. for testing only\r\n            if not self.IO_Board.get_pump_reading() == True:  # if the pump is not running\r\n                # launch the dialog box signifying this issue\r\n                self.user_prompt_pump_not_running_signal.emit(pump_status)\r\n                try:\r\n                    self.wait_for_cont()\r\n                except AbortException:\r\n                    return self.abort()\r\n            else:\r\n                water_level = self.IO_Board.get_water_level()\r\n                if not water_level == 'level':  # if the water level is not level\r\n                    # launch the dialog box signifying this issue\r\n                    self.user_prompt_signal_water_too_low_signal.emit(water_level)\r\n                    try:\r\n                        self.wait_for_cont()\r\n                    except AbortException:\r\n                        return\r\n                else:\r\n                    break\r\n\r\n        self.step_complete = True\r\n\r\n    '''latches info from user in MainWindow to manager local vars'''\r\n\r\n    @pyqtSlot(str, str, str)\r\n    def pretest_info_slot(self, operator_name, ua_serial_no, comment):\r\n        self.test_data[\"operarator_name\"] = operator_name\r\n        self.test_data[\"ua_serial_number\"] = ua_serial_no\r\n        self.test_data[\"test_comment\"] = comment\r\n        self.cont()\r\n\r\n    '''Find UA element with given number'''\r\n\r\n    def find_element(self, variable_list):\r\n        element = int(re.search(r'\\d+', str(variable_list['Element'])).group())\r\n\r\n        #Update UI visual to reflect the element we are on\r\n        self.element_number_signal.emit(str(element))\r\n\r\n        element_x_coordinate = self.element_x_coordinates[element]\r\n        element_r_coordinate = self.element_r_coordinates[element]\r\n        print(f\"Finding element {element}, near coordinate x = {element_x_coordinate}, r = {element_r_coordinate}\")\r\n\r\n        t.sleep(.1)\r\n        x_increment_MM = float(variable_list['X Incr. (mm)'])\r\n        XPts = int(variable_list['X #Pts.'])\r\n        thetaIncrDeg = float(variable_list['Theta Incr. (deg)'])\r\n        thetaPts = int(variable_list['Theta #Pts.'])\r\n        scope_channel = int(variable_list['Scope channel'][8:])\r\n        acquisition_type = variable_list['Acquisition type']\r\n        averages = int(variable_list['Averages'])\r\n        data_storage = variable_list['Data storage']\r\n        storage_location = variable_list['Storage location']\r\n        data_directory = variable_list[\"Data directory\"]\r\n        maxPosErrMM = float(variable_list[\"Max. position error (+/- mm)\"])\r\n        elemPosTest = bool(variable_list[\"ElementPositionTest\"])\r\n\r\n        # Configure hardware\r\n        if acquisition_type.upper() == 'N Averaged Waveform'.upper():\r\n            self.Oscilloscope.SetAveraging(averages)\r\n        else:\r\n            self.Oscilloscope.SetAveraging(1)\r\n\r\n        # Loop over x through a given range, move to the position where maximal RMS voltage was measured\r\n        x_sweep_waveforms = list()\r\n        x_positions = list()\r\n        x_rms_values = list()\r\n\r\n        # sweep from the expected element position minus the max error to the expected element position plus max error\r\n        position = -1 * (XPts * x_increment_MM)/2 + element_x_coordinate\r\n\r\n        # begin with arbitrarily low values\r\n        x_max_rms = sys.float_info.min\r\n        x_max_position = sys.float_info.min\r\n        for i in range(XPts):\r\n            self.Motors.go_to_position(['X'], [position])\r\n            position = position + abs(x_increment_MM)\r\n\r\n            voltage, time = self.Oscilloscope.capture(scope_channel)\r\n            if not data_storage.upper() == 'Do not store'.upper():\r\n                x_sweep_waveforms.append([voltage, time])\r\n\r\n            rms = self.find_rms(time_s=time, voltage_v=voltage)\r\n\r\n            if rms > x_max_rms:\r\n                x_max_rms = rms\r\n                x_max_position = position\r\n\r\n            x_positions.append(position)\r\n            x_rms_values.append(rms)\r\n            self.profile_plot_signal.emit(x_positions, x_rms_values, 'Distance (mm)')\r\n\r\n        self.log(f\"Maximum of {x_max_rms} @ x = {x_max_position} mm. Going there.\")\r\n\r\n        #update element x position\r\n        self.element_x_coordinates[element] = x_max_position\r\n\r\n        status = self.Motors.go_to_position(['X'], [x_max_position])\r\n\r\n        if not status and self.config[\"debugging\"][\"end_script_on_errors\"]:\r\n            self.abort()\r\n            return\r\n\r\n        self.scan_data[\"X sweep waveforms\"] = x_sweep_waveforms\r\n\r\n        # Loop over r through a given range, move to the position where maximal RMS voltage was measured\r\n        r_sweep_waveforms = list()\r\n        position = -1 * (thetaPts * thetaIncrDeg)/2 + self.config[\"WTF_PositionParameters\"][\"ThetaHomeCoord\"]\r\n        r_max_rms = -1\r\n        r_max_position = 0\r\n        r_positions = list()\r\n        r_rms_values = list()\r\n\r\n        for i in range(thetaPts):\r\n            self.Motors.go_to_position(['R'], [position])\r\n            position = position + thetaIncrDeg\r\n\r\n            voltage, time = self.Oscilloscope.capture(scope_channel)\r\n            if not data_storage.upper() == 'Do not store'.upper():\r\n                r_sweep_waveforms.append([voltage, time])\r\n\r\n            rms = self.find_rms(time_s=time, voltage_v=voltage)\r\n\r\n            if rms > r_max_rms:\r\n                r_max_rms = rms\r\n                r_max_position = position\r\n\r\n            r_positions.append(position)\r\n            r_rms_values.append(rms)\r\n            self.profile_plot_signal.emit(r_positions, r_rms_values, 'Angle (deg)')\r\n\r\n        self.Motors.go_to_position(['R'], [r_max_position])\r\n        self.scan_data[\"Theta sweep waveforms\"] = r_sweep_waveforms\r\n\r\n        self.log(f\"Maximum of {r_max_rms} @ theta = {r_max_position} degrees. Going there.\")\r\n        #update element r position\r\n        self.element_r_coordinates[element] = r_max_position\r\n\r\n        self.step_complete = True\r\n\r\n    '''Measure the efficiency of an element'''\r\n\r\n    def measure_element_efficiency_rfb(self, variable_list):\r\n        element = int(re.search(r'\\d+', str(variable_list['Element'])).group())\r\n        element_x_coordinate = self.element_x_coordinates[element]\r\n        element_r_coordinate = self.element_x_coordinates[element]\r\n        print(f\"Measuring effeciency of {element}, at coordinate x={element_x_coordinate}, r={element_r_coordinate}\")\r\n        self.element_number_signal.emit(str(element))\r\n        self.Motors.go_to_position(['X','R'], [element_x_coordinate,element_r_coordinate])\r\n        frequency_range = variable_list['Frequency range']\r\n        on_off_cycles = int(variable_list['RFB.#on/off cycles'])\r\n        rfb_on_time = float(variable_list['RFB.On time (s)'])\r\n        rfb_off_time = float(variable_list['RFB.Off time (s)'])\r\n\r\n        if frequency_range == \"High frequency\":\r\n            frequency_Hz = self.parent.ua_calibration_tab.High_Frequency_MHz * 1000000\r\n        elif frequency_range == \"Low frequency\":\r\n            frequency_Hz = self.parent.ua_calibration_tab.Low_Frequency_MHz * 1000000\r\n        else:\r\n            self.log(\"Improper frequency set, defaulting to low frequency\")\r\n            frequency_Hz = self.parent.ua_calibration_tab.Low_Frequency_MHz * 1000000\r\n\r\n        self.AWG.SetFrequency_Hz(frequency_Hz)\r\n        self.AWG.SetOutput(False)\r\n\r\n        self.Balance.zero_balance_instantly()\r\n\r\n        forward_powers_w = list()\r\n        forward_powers_time_s = list()\r\n        reflected_powers_w = list()\r\n        reflected_powers_time_s = list()\r\n        acoustic_powers_w = list()\r\n        acoustic_powers_time_s = list()\r\n\r\n        awg_on = list()\r\n\r\n        startTime = t.time()\r\n        current_cycle = 1\r\n\r\n        while current_cycle <= on_off_cycles:\r\n            cycle_start_time = t.time()\r\n            self.AWG.SetOutput(True)\r\n            while t.time() - cycle_start_time < rfb_on_time:  # for the duration of rfb on time\r\n                forward_power_w = self.Forward_Power_Meter.get_reading()\r\n                forward_powers_w.append(forward_power_w)\r\n                forward_powers_time_s.append(t.time() - startTime)\r\n\r\n                reflected_power_w = self.Reflected_Power_Meter.get_reading()\r\n                reflected_powers_w.append(reflected_power_w)\r\n                reflected_powers_time_s.append(t.time() - startTime)\r\n\r\n                balance_reading = self.Balance.get_reading()\r\n                if balance_reading is not None:\r\n                    acoustic_power_w = calculate_power_from_balance_reading(balance_reading*-30)\r\n                    acoustic_powers_w.append(acoustic_power_w)\r\n                    acoustic_powers_time_s.append(t.time() - startTime)\r\n                    awg_on.append(True)\r\n\r\n                # package data to send it to the rfb ui tab\r\n                args = dict()\r\n                args['forward_s'] = forward_powers_time_s\r\n                args['forward_w'] = forward_powers_w\r\n                args['reflected_s'] = reflected_powers_time_s\r\n                args['reflected_w'] = reflected_powers_w\r\n                args['acoustic_s'] = acoustic_powers_time_s\r\n                args['acoustic_w'] = acoustic_powers_w\r\n                args['awg_on'] = awg_on\r\n                args['grams'] = balance_reading\r\n                args['forward_power_w'] = forward_power_w\r\n                args['reflected_power_w'] = reflected_power_w\r\n                self.rfb_tab_signal.emit(args)\r\n\r\n                self.app.processEvents()\r\n\r\n            #  turn off awg\r\n            self.AWG.SetOutput(False)\r\n\r\n            while t.time() - cycle_start_time < rfb_on_time + rfb_off_time:  # for the duration of rfb on time\r\n                forward_power_w = self.Forward_Power_Meter.get_reading()\r\n                forward_powers_w.append(forward_power_w)\r\n                forward_powers_time_s.append(t.time() - startTime)\r\n\r\n                reflected_power_w = self.Reflected_Power_Meter.get_reading()\r\n                reflected_powers_w.append(reflected_power_w)\r\n                reflected_powers_time_s.append(t.time() - startTime)\r\n\r\n                balance_reading = self.Balance.get_reading()\r\n                if balance_reading is not None:\r\n                    acoustic_power_w = calculate_power_from_balance_reading(balance_reading)\r\n                    acoustic_powers_w.append(acoustic_power_w)\r\n                    acoustic_powers_time_s.append(t.time() - startTime)\r\n                    awg_on.append(False)\r\n\r\n                # package data to send it to the rfb ui tab\r\n                args = dict()\r\n                args = dict()\r\n                args['forward_s'] = forward_powers_time_s\r\n                args['forward_w'] = forward_powers_w\r\n                args['reflected_s'] = reflected_powers_time_s\r\n                args['reflected_w'] = reflected_powers_w\r\n                args['acoustic_s'] = acoustic_powers_time_s\r\n                args['acoustic_w'] = acoustic_powers_w\r\n                args['awg_on'] = awg_on\r\n                args['grams'] = balance_reading\r\n                args['forward_power_w'] = forward_power_w\r\n                args['reflected_power_w'] = reflected_power_w\r\n                self.rfb_tab_signal.emit(args)\r\n                self.app.processEvents()\r\n\r\n            current_cycle = current_cycle + 1  # we just passed a cycle at this point in the code\r\n\r\n        print(f\"Final time: {t.time() - startTime}\")\r\n\r\n        self.element_number_signal.emit(str(element))\r\n        self.step_complete = True\r\n\r\n    '''Save scan results to a file'''\r\n\r\n    def save_results(self, variable_list, calibration_data):  # calibration_data is the data gathered by the UA test\r\n        save_summary_file = bool(distutils.util.strtobool(variable_list[\"Save summary file\"]))\r\n        write_uac_calibration = bool(distutils.util.strtobool(variable_list[\"Write UA Calibration\"]))\r\n        prompt_for_calibration_write = bool(distutils.util.strtobool(variable_list[\"PromptForCalWrite\"]))\r\n\r\n        if prompt_for_calibration_write:  # displays the \"write to UA\" dialog box if this variable is true\r\n            self.write_cal_data_to_ua_dialog(calibration_data)\r\n\r\n        self.step_complete = True\r\n\r\n    '''Prompt user for action'''\r\n\r\n    def prompt_user_for_action(self, variable_list):\r\n        prompt_type = variable_list[\"Prompt type\"]\r\n        self.step_complete = True\r\n\r\n    '''Return axis to zero coordinate'''\r\n\r\n    def home_system(self, variable_list):\r\n        axis_to_home = variable_list['Axis to home']\r\n        if axis_to_home == 'X':\r\n            self.retracting_ua_warning_signal.emit()  # launch the retracting UA in the x direction warning box\r\n            try:\r\n                self.wait_for_cont()\r\n            except AbortException:\r\n                return self.abort()\r\n\r\n        # TODO: have the pump home in the desired direction\r\n\r\n        self.step_complete = True\r\n\r\n    '''Warn the user that the UA is being retracted in x'''\r\n\r\n    def retract_ua_warning(self):\r\n        self.retracting_ua_warning_signal.emit()\r\n\r\n    # calibration_data should be a 2d list: 1st col: cal data array, 2nd col: low freq, 3rd col: high freq\r\n    def write_cal_data_to_ua_dialog(self, calibration_data):\r\n        self.write_cal_data_to_ua_signal.emit(calibration_data)\r\n\r\n    def printList(self, list2):\r\n        for x in range(len(list2)):\r\n            print(list2[x])\r\n\r\n    def printList2(self, list2):\r\n        print(str(list2)[1:-1])\r\n\r\n    @pyqtSlot(str)\r\n    def exec_command(self, command):\r\n        if 'CLOSE' in command.upper():\r\n            self.log('Wrapping up')\r\n            self.wrap_up()\r\n            self.cmd = ''\r\n            return\r\n        if 'ABORT' in command.upper():\r\n            self.abort()\r\n            self.cmd = ''\r\n            return\r\n        self.cmd = command\r\n        self.condition.wakeAll()\r\n\r\n    def wrap_up(self):\r\n        for device in self.devices:\r\n            device.wrap_up()\r\n        self.stay_alive = False\r\n\r\n    def log(self, message, level='info'):\r\n        log_msg(self, root_logger=root_logger, message=message, level=level)\r\n\r\n    def frequency_sweep(self, search_mode, frequency_mode):\r\n        if search_mode == \"fine\":\r\n            self.step = self.config[\"FrequencyParameters\"][\"Search\"][\"FineIncr(MHz)\"] * 1000000\r\n        elif search_mode == \"coarse\":\r\n            self.step = self.config[\"FrequencyParameters\"][\"Search\"][\"CoarseIncr(MHz)\"] * 1000000\r\n\r\n        if frequency_mode == \"HF\":\r\n            self.freq_lowlimit_hz = self.config[\"FrequencyParameters\"][\"HF\"][\"LowFreqLimit(MHz)\"] * 1000000\r\n            self.freq_highlimit_hz = self.config[\"FrequencyParameters\"][\"HF\"][\"HighFreqLimit(MHz)\"] * 1000000\r\n        elif frequency_mode == \"LF\":\r\n            self.freq_lowlimit_hz = self.config[\"FrequencyParameters\"][\"LF\"][\"LowFreqLimit(MHz)\"] * 1000000\r\n            self.freq_highlimit_hz = self.config[\"FrequencyParameters\"][\"LF\"][\"HighFreqLimit(MHz)\"] * 1000000\r\n\r\n        self.list_of_rms_values = list()\r\n        self.list_of_frequencies = list()\r\n\r\n        for x in np.arange(self.freq_lowlimit_hz, self.freq_highlimit_hz, self.step):\r\n            self.AWG.SetFrequency_Hz(x)  # set frequency accoding to step (coarse/fine) and x incremenet\r\n            self.list_of_frequencies.append(x)  # add the frequency to the list\r\n            self.times_s, self.voltages_v = self.Oscilloscope.capture(1)\r\n            # populates times_s and voltages_v with set frequency\r\n            self.voltages_v_squared = np.square(self.voltages_v)  # squares every value in the voltage graph\r\n            self.list_of_rms_values.append(\r\n                integrate.simps(self.voltages_v_squared, self.times_s, dx=None, axis=0))  # returns single value\r\n            times_s, voltages_v = self.Oscilloscope.capture(1)  # populates times_s and voltages_v with set frequency\r\n\r\n            self.list_of_rms_values.append(self.find_rms(times_s, voltages_v))\r\n        self.profile_plot_signal.emit(self.list_of_frequencies, self.list_of_rms_values, \"Frequency (Hz)\")\r\n        # frequencies will be on the x-axis\r\n\r\n    '''Returns the voltage squared integral of a oscilloscope waveform'''\r\n\r\n    def find_rms(self, time_s, voltage_v):\r\n        dx = 0\r\n        for i in range(1, len(time_s)):\r\n            dx = time_s[i] - time_s[i - 1]\r\n            if not dx == 0:\r\n                break\r\n\r\n        voltages_v_squared = np.square(voltage_v)\r\n\r\n        if dx == 0:\r\n            self.log(level='Error', message='Error in find_rms. No delta x found, cannot integrate')\r\n            return\r\n\r\n        return integrate.simps(y=voltages_v_squared, dx=dx, axis=0)\r\n\r\n\r\nclass AbortException(Exception):\r\n    pass\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/manager.py b/manager.py
--- a/manager.py	(revision 62da6dd2bc9e45350e2b8893e11368b228a60eee)
+++ b/manager.py	(date 1649868724797)
@@ -129,6 +129,7 @@
 
         # Script file
         self.script = None
+        self.script_log = list()
 
         # Script data
         self.taskArgs = None
@@ -377,6 +378,8 @@
         self.starttime = t.time()
 
     def load_script(self, path):
+        # get UA serial no. and append behind date
+        self.log_2d_list.append([datetime.now().strftime("%Y.%m.%d-%H.%M"), '', '', '', ''])
         self.scripting = True
         self.script = open(path, "r")
 
Index: logs/wtf.log
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>2022-04-08 12:17:51,975 [INFO] [PowerMeter] [ui_thread] : Forward_Power_Meter (model PWR-SEN-6GHS, serial 11408040323 connected successfully\r\n2022-04-08 12:17:52,584 [INFO] [PowerMeter] [ui_thread] : Reflected_Power_Meter (model PWR-SEN-6GHS, serial 11506210019 connected successfully\r\n2022-04-08 12:17:52,661 [INFO] [UAInterfaceBox] [ui_thread] : Attempting to connect to WTFIB... \r\n2022-04-08 12:17:52,672 [INFO] [UAInterfaceBox] [ui_thread] : WTFIB connected successfully\r\n2022-04-08 12:17:52,673 [INFO] [VIX_Motor_Controller] [ui_thread] : Connecting to motor controller...\r\n2022-04-08 12:17:52,758 [INFO] [VIX_Motor_Controller] [ui_thread] : 0MA\r\n2022-04-08 12:17:52,758 [INFO] [VIX_Motor_Controller] [ui_thread] : output = b'0MA\\r\\n'\r\n2022-04-08 12:17:52,933 [INFO] [VIX_Motor_Controller] [ui_thread] : Done setting up\r\n2022-04-08 12:17:52,934 [INFO] [VIX_Motor_Controller] [ui_thread] : Motor controller connected and set to default settings\r\n2022-04-08 12:17:52,935 [INFO] [KeysightOscilloscope] [ui_thread] : Attempting to connect to oscilloscope...\r\n2022-04-08 12:17:53,355 [INFO] [KeysightOscilloscope] [ui_thread] : Oscilloscope connected and set to default settings\r\n2022-04-08 12:18:04,257 [INFO] [Manager] [manager_thread] : Loading script\r\n2022-04-08 12:19:48,230 [INFO] [VIX_Motor_Controller] [ui_thread] : 0MA\r\n2022-04-08 12:19:48,232 [INFO] [VIX_Motor_Controller] [ui_thread] : output = b'0MA\\r\\n'\r\n2022-04-08 12:19:48,454 [INFO] [VIX_Motor_Controller] [ui_thread] : Done setting up\r\n2022-04-08 12:20:45,881 [INFO] [VIX_Motor_Controller] [ui_thread] : Stopping motion\r\n2022-04-08 12:20:46,035 [INFO] [VIX_Motor_Controller] [ui_thread] : Stopping motion\r\n2022-04-08 12:21:13,414 [INFO] [VIX_Motor_Controller] [ui_thread] : 0MA\r\n2022-04-08 12:21:13,416 [INFO] [VIX_Motor_Controller] [ui_thread] : output = b'0MA\\r\\n'\r\n2022-04-08 12:21:13,639 [INFO] [VIX_Motor_Controller] [ui_thread] : Done setting up\r\n2022-04-08 12:21:44,919 [INFO] [VIX_Motor_Controller] [ui_thread] : 0MA\r\n2022-04-08 12:21:44,922 [INFO] [VIX_Motor_Controller] [ui_thread] : output = b'0MA\\r\\n'\r\n2022-04-08 12:21:45,111 [INFO] [VIX_Motor_Controller] [ui_thread] : Done setting up\r\n2022-04-08 12:22:14,877 [INFO] [VIX_Motor_Controller] [ui_thread] : Stopping motion\r\nb'0MA\\r\\n'\r\n2022-04-08 12:21:45,111 [INFO] [VIX_Motor_Controller] [ui_thread] : Done setting up\r\n2022-04-08 12:22:14,877 [INFO] [VIX_Motor_Controller] [ui_thread] : Stopping motion\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/logs/wtf.log b/logs/wtf.log
--- a/logs/wtf.log	(revision 62da6dd2bc9e45350e2b8893e11368b228a60eee)
+++ b/logs/wtf.log	(date 1649865941022)
@@ -1,27 +1,0 @@
-2022-04-08 12:17:51,975 [INFO] [PowerMeter] [ui_thread] : Forward_Power_Meter (model PWR-SEN-6GHS, serial 11408040323 connected successfully
-2022-04-08 12:17:52,584 [INFO] [PowerMeter] [ui_thread] : Reflected_Power_Meter (model PWR-SEN-6GHS, serial 11506210019 connected successfully
-2022-04-08 12:17:52,661 [INFO] [UAInterfaceBox] [ui_thread] : Attempting to connect to WTFIB... 
-2022-04-08 12:17:52,672 [INFO] [UAInterfaceBox] [ui_thread] : WTFIB connected successfully
-2022-04-08 12:17:52,673 [INFO] [VIX_Motor_Controller] [ui_thread] : Connecting to motor controller...
-2022-04-08 12:17:52,758 [INFO] [VIX_Motor_Controller] [ui_thread] : 0MA
-2022-04-08 12:17:52,758 [INFO] [VIX_Motor_Controller] [ui_thread] : output = b'0MA\r\n'
-2022-04-08 12:17:52,933 [INFO] [VIX_Motor_Controller] [ui_thread] : Done setting up
-2022-04-08 12:17:52,934 [INFO] [VIX_Motor_Controller] [ui_thread] : Motor controller connected and set to default settings
-2022-04-08 12:17:52,935 [INFO] [KeysightOscilloscope] [ui_thread] : Attempting to connect to oscilloscope...
-2022-04-08 12:17:53,355 [INFO] [KeysightOscilloscope] [ui_thread] : Oscilloscope connected and set to default settings
-2022-04-08 12:18:04,257 [INFO] [Manager] [manager_thread] : Loading script
-2022-04-08 12:19:48,230 [INFO] [VIX_Motor_Controller] [ui_thread] : 0MA
-2022-04-08 12:19:48,232 [INFO] [VIX_Motor_Controller] [ui_thread] : output = b'0MA\r\n'
-2022-04-08 12:19:48,454 [INFO] [VIX_Motor_Controller] [ui_thread] : Done setting up
-2022-04-08 12:20:45,881 [INFO] [VIX_Motor_Controller] [ui_thread] : Stopping motion
-2022-04-08 12:20:46,035 [INFO] [VIX_Motor_Controller] [ui_thread] : Stopping motion
-2022-04-08 12:21:13,414 [INFO] [VIX_Motor_Controller] [ui_thread] : 0MA
-2022-04-08 12:21:13,416 [INFO] [VIX_Motor_Controller] [ui_thread] : output = b'0MA\r\n'
-2022-04-08 12:21:13,639 [INFO] [VIX_Motor_Controller] [ui_thread] : Done setting up
-2022-04-08 12:21:44,919 [INFO] [VIX_Motor_Controller] [ui_thread] : 0MA
-2022-04-08 12:21:44,922 [INFO] [VIX_Motor_Controller] [ui_thread] : output = b'0MA\r\n'
-2022-04-08 12:21:45,111 [INFO] [VIX_Motor_Controller] [ui_thread] : Done setting up
-2022-04-08 12:22:14,877 [INFO] [VIX_Motor_Controller] [ui_thread] : Stopping motion
-b'0MA\r\n'
-2022-04-08 12:21:45,111 [INFO] [VIX_Motor_Controller] [ui_thread] : Done setting up
-2022-04-08 12:22:14,877 [INFO] [VIX_Motor_Controller] [ui_thread] : Stopping motion
